---==== SERVICES ====--
local Players = game:GetService("Players")
local RS = game:GetService("ReplicatedStorage")
local UIS = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local Remote = RS:WaitForChild("Event", 9e9)

--==== SETTINGS ====--
local HIT_DELAY = 0.1
local STOMP_DELAY = 0.05
local STOMP_REPEAT = 5
local STOMP_RETRY_TIME = 2
local STOMP_HP = 1
local FOLLOW_THRESHOLD = 1

--==== STATE ====--
local enabled = false
local mode = "All"
local followStyle = "Behind"
local followDistance = 2
local kills = 0
local currentTarget = nil

--==== HELPER FUNCS ====--
local function getHRP(char)
	return char and char:FindFirstChild("HumanoidRootPart")
end

local function getHum(char)
	return char and char:FindFirstChildOfClass("Humanoid")
end

local function alive(plr)
	if not plr or not plr:IsDescendantOf(game) then return false end
	if not plr.Character then return false end
	local hum = getHum(plr.Character)
	local hrp = getHRP(plr.Character)
	return hum and hrp and hum.Health > 0
end

--==== FOLLOW OFFSET ====--
local function getOffset()
	local d = followDistance
	return {
		Behind = Vector3.new(0, 0, d),    -- swapped
		Front  = Vector3.new(0, 0, -d),   -- swapped
		Left   = Vector3.new(-d, 0, 0),
		Right  = Vector3.new(d, 0, 0),
		Above  = Vector3.new(0, d * 2, 0),
		Below  = Vector3.new(0, -d * 2, 0)
	}
end

local function smartFollow(myHRP, targetHRP)
	local offset = getOffset()[followStyle]
	local goal = targetHRP.Position + targetHRP.CFrame:VectorToWorldSpace(offset)
	if (myHRP.Position - goal).Magnitude > FOLLOW_THRESHOLD then
		myHRP.CFrame = CFrame.new(goal, targetHRP.Position)
	end
end

--==== COMBAT REMOTES ====--
local function hit(part)
	Remote:FireServer({
		Event = "Hit",
		ClientHitbox = { part }
	})
end

local function stomp()
	Remote:FireServer({ Event = "Stomp" })
end

--==== GUI ====--
local gui = Instance.new("ScreenGui", LocalPlayer.PlayerGui)
gui.Name = "CombatBotGUI"
gui.ResetOnSpawn = false

local function button(text, y)
	local b = Instance.new("TextButton", gui)
	b.Size = UDim2.new(0, 180, 0, 30)
	b.Position = UDim2.new(0, 20, 0, y)
	b.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
	b.TextColor3 = Color3.new(1,1,1)
	b.Font = Enum.Font.SourceSansBold
	b.TextScaled = true
	b.Text = text
	return b
end

local toggleBtn = button("AUTO: OFF", 80)
local targetBtn = button("Target: All", 120)
local posBtn = button("Position: Behind", 160)
local distBtn = button("Distance: 2", 200)

local status = Instance.new("TextLabel", gui)
status.Size = UDim2.new(0, 260, 0, 28)
status.Position = UDim2.new(0, 20, 0, 240)
status.BackgroundTransparency = 1
status.TextColor3 = Color3.new(1,1,1)
status.Font = Enum.Font.SourceSansBold
status.TextScaled = true
status.Text = "Status: Idle"

local killLabel = Instance.new("TextLabel", gui)
killLabel.Size = UDim2.new(0, 260, 0, 28)
killLabel.Position = UDim2.new(0, 20, 0, 270)
killLabel.BackgroundTransparency = 1
killLabel.TextColor3 = Color3.new(1,1,1)
killLabel.Font = Enum.Font.SourceSansBold
killLabel.TextScaled = true
killLabel.Text = "Kills: 0"

local function updateGUI()
	toggleBtn.Text = enabled and "AUTO: ON" or "AUTO: OFF"
	targetBtn.Text = "Target: " .. mode
	posBtn.Text = "Position: " .. followStyle
	distBtn.Text = "Distance: " .. tostring(followDistance)
	killLabel.Text = "Kills: " .. kills
end

--==== GUI LOGIC ====--
toggleBtn.MouseButton1Click:Connect(function()
	enabled = not enabled
	updateGUI()
end)

UIS.InputBegan:Connect(function(input, gp)
	if gp then return end
	if input.KeyCode == Enum.KeyCode.K then
		enabled = not enabled
		updateGUI()
	end
end)

targetBtn.MouseButton1Click:Connect(function()
	local opts = { "All", "Nearest" }
	for _,p in ipairs(Players:GetPlayers()) do
		if p ~= LocalPlayer then table.insert(opts, p.Name) end
	end
	mode = opts[(table.find(opts, mode) or 1) % #opts + 1]
	updateGUI()
end)

posBtn.MouseButton1Click:Connect(function()
	local styles = { "Behind", "Front", "Left", "Right", "Above", "Below" }
	followStyle = styles[(table.find(styles, followStyle) or 1) % #styles + 1]
	updateGUI()
end)

distBtn.MouseButton1Click:Connect(function()
	followDistance = followDistance % 10 + 1
	updateGUI()
end)

--==== TARGET FUNCTION ====--
local function getTarget(myHRP)
	if mode == "Nearest" then
		local best, dist = nil, math.huge
		for _,p in ipairs(Players:GetPlayers()) do
			if p ~= LocalPlayer and alive(p) then
				local hrp = getHRP(p.Character)
				local d = (hrp.Position - myHRP.Position).Magnitude
				if d < dist then
					best, dist = p, d
				end
			end
		end
		return best

	elseif mode ~= "All" then
		local p = Players:FindFirstChild(mode)
		if p and alive(p) then
			return p -- lock only to selected player
		else
			return nil
		end
	end

	-- fallback to anyone
	for _,p in ipairs(Players:GetPlayers()) do
		if p ~= LocalPlayer and alive(p) then
			return p
		end
	end
end

--==== MAIN LOOP ====--
task.spawn(function()
	while true do
		RunService.Heartbeat:Wait()
		if not enabled then continue end

		local myHRP = getHRP(LocalPlayer.Character)
		if not myHRP then continue end

		if not currentTarget or not currentTarget:IsDescendantOf(game) then
			currentTarget = getTarget(myHRP)
		end
		if not currentTarget then continue end

		status.Text = "Status: Targeting " .. currentTarget.Name

		while enabled and currentTarget:IsDescendantOf(game) do
			local char = currentTarget.Character
			local hum = getHum(char)
			local hrp = getHRP(char)
			if not hum or not hrp then break end

			-- ATTACK PHASE
			while enabled and hum.Health > STOMP_HP do
				smartFollow(myHRP, hrp)
				hit(hrp)
				task.wait(HIT_DELAY)
			end

			-- STOMP PHASE w/ ATTACK every 0.7s
			local stompStart = tick()
			local lastHit = 0
			while enabled and hum.Health <= STOMP_HP and hum.Health > 0 do
				myHRP.CFrame = hrp.CFrame

				for _ = 1, STOMP_REPEAT do
					stomp()
					task.wait(STOMP_DELAY)
				end

				if tick() - lastHit >= 0.7 then
					hit(hrp)
					lastHit = tick()
				end

				if tick() - stompStart >= STOMP_RETRY_TIME then
					break
				end
			end

			if hum.Health <= 0 then
				local oldChar = char
				repeat task.wait(0.1)
				until currentTarget.Character ~= oldChar or not currentTarget:IsDescendantOf(game)
				kills += 1
				updateGUI()
			end
		end

		currentTarget = nil
	end
end)
